"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => GitHubActionsReporter
});
module.exports = __toCommonJS(src_exports);
var import_core = require("@actions/core");

// src/stacktrace/parse.ts
var stackIgnorePatterns = [
  "node:internal",
  "/vitest/dist/",
  "/node_modules/chai/",
  "/node_modules/tinypool/",
  "/node_modules/tinyspy/"
];
var slash = (str) => str.replace(/\\/g, "/");
function notNullish(v) {
  return v != null;
}
function extractLocation(urlLike) {
  if (!urlLike.includes(":"))
    return [urlLike];
  const regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
  const parts = regExp.exec(urlLike.replace(/[()]/g, ""));
  if (!parts)
    return [urlLike];
  return [parts[1], parts[2] || void 0, parts[3] || void 0];
}
var parseStacktrace = (stackStr, full = false) => {
  const stackFrames = stackStr.split("\n").map((raw) => {
    let line = raw.trim();
    if (line.includes("(eval "))
      line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
    let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
    const location = sanitizedLine.match(/ (\(.+\)$)/);
    sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
    const [url, lineNumber, columnNumber] = extractLocation(
      location ? location[1] : sanitizedLine
    );
    let method = location && sanitizedLine || "";
    let file = url && ["eval", "<anonymous>"].includes(url) ? void 0 : url;
    if (!file || !lineNumber || !columnNumber)
      return null;
    if (method.startsWith("async "))
      method = method.slice(6);
    if (file.startsWith("file://"))
      file = file.slice(7);
    if (!full && stackIgnorePatterns.some((p) => file && file.includes(p)))
      return null;
    return {
      method,
      file: slash(file),
      line: parseInt(lineNumber),
      column: parseInt(columnNumber)
    };
  }).filter(notNullish);
  return stackFrames;
};

// src/stacktrace/stringify.ts
var _a;
var repository = ((_a = process.env.GITHUB_REPOSITORY) == null ? void 0 : _a.split("/")[1]) ?? "";
var repositoryPrefixes = [
  `D:/a/${repository}/`,
  `/home/runner/work/${repository}/`
];
var stringifyStacktrace = (stack, trimRepositoryPrefix) => {
  return stack.map((s) => {
    let file = s.file;
    if (trimRepositoryPrefix) {
      file = trimPrefixes(file, repositoryPrefixes);
    }
    return `  at ${s.method ? `${s.method} ` : ""}${file}:${s.line}:${s.column}`;
  }).join("\n");
};
var trimPrefixes = (str, prefixes) => {
  for (const p of prefixes) {
    if (str.startsWith(p)) {
      str = str.slice(p.length);
      break;
    }
  }
  return str;
};

// src/index.ts
var GitHubActionsReporter = class {
  constructor({
    trimRepositoryPrefix = true,
    hideStackTrace = false
  } = {}) {
    this.options = {
      trimRepositoryPrefix,
      hideStackTrace
    };
  }
  onInit(ctx) {
    this.ctx = ctx;
  }
  async onFinished(files) {
    if (!files)
      return;
    (0, import_core.startGroup)("Vitest Annotations");
    this.reportFiles(files);
    (0, import_core.endGroup)();
  }
  reportFiles(files) {
    var _a2;
    for (const file of files) {
      if ((_a2 = file.result) == null ? void 0 : _a2.error) {
        this.reportSuiteError(file.filepath, file);
      }
      this.reportTasks(file.filepath, file.tasks);
    }
  }
  reportTasks(filename, tasks) {
    var _a2;
    for (const task of tasks) {
      if (task.type === "suite") {
        if ((_a2 = task.result) == null ? void 0 : _a2.error) {
          this.reportSuiteError(filename, task);
        }
        this.reportTasks(filename, task.tasks);
      } else if (task.type === "test") {
        this.reportTest(filename, task);
      } else if (task.type === "benchmark") {
      } else {
        checkNever(task);
      }
    }
  }
  reportSuiteError(filename, suite) {
    var _a2, _b, _c;
    const stackTrace = this.parseStacktrace((_b = (_a2 = suite.result) == null ? void 0 : _a2.error) == null ? void 0 : _b.stackStr);
    const position = this.getPositionFromError(filename, stackTrace);
    const message = this.createMessage(stackTrace);
    (0, import_core.error)(message, {
      ...position,
      title: this.getErrorTitle((_c = suite.result) == null ? void 0 : _c.error, "Failed Suite")
    });
  }
  reportTest(filename, test) {
    var _a2, _b, _c, _d;
    if (((_a2 = test.result) == null ? void 0 : _a2.state) !== "fail")
      return;
    const stackTrace = this.parseStacktrace((_c = (_b = test.result) == null ? void 0 : _b.error) == null ? void 0 : _c.stackStr);
    const position = this.getPositionFromError(filename, stackTrace);
    const message = this.createMessage(stackTrace);
    (0, import_core.error)(message, {
      ...position,
      title: this.getErrorTitle((_d = test.result) == null ? void 0 : _d.error, "Failed Test")
    });
  }
  parseStacktrace(stacktraceStr) {
    if (!stacktraceStr)
      return void 0;
    return parseStacktrace(stacktraceStr);
  }
  createMessage(stacktrace) {
    if (this.options.hideStackTrace)
      return ".";
    if (!stacktrace)
      return "No stacktrace";
    return stringifyStacktrace(stacktrace, this.options.trimRepositoryPrefix);
  }
  getPositionFromError(filename, stacktrace) {
    if (!stacktrace || !stacktrace[0]) {
      return { file: filename };
    }
    const { file, line, column } = stacktrace[0];
    return {
      file,
      startLine: line,
      startColumn: column
    };
  }
  getErrorTitle(error2, fallback) {
    return `${(error2 == null ? void 0 : error2.name) ?? "Error"}: ${(error2 == null ? void 0 : error2.message) ?? fallback}`;
  }
};
function checkNever(_) {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
  https://github.com/vitest-dev/vitest/blob/f1cdfb6960a1eb39345f973529bc1e72ab4090b4/packages/vitest/src/utils/source-map.ts#L59-L115
  MIT License
  Copyright (c) 2021-Present Anthony Fu <https://github.com/antfu>
  Copyright (c) 2021-Present Matias Capeletto <https://github.com/patak-dev>
  https://github.com/vitest-dev/vitest/blob/main/LICENSE
*/
//# sourceMappingURL=index.cjs.map